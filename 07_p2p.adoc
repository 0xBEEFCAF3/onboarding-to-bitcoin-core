= P2P
include::settings.adoc[]

This document was created from Bitcoin Core at commit https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e[4b5659c6b115315c9fd2902b4edd4b960a5e066e]

== Design philosophy

Bitcoin Core's P2P design philosophy is outlined in the bitcoin devwiki article https://github.com/bitcoin-core/bitcoin-devwiki/wiki/P2P-Design-Philosophy[P2P Design Philosophy].
A synopsis of the ideas can be found in the first paragraph which states:

[quote]
____
For the Bitcoin network to remain in consensus, the network of nodes must not be partitioned.
So for an individual node to remain in consensus with the network, it must have at least one connection to that network of peers that share its consensus rules.

...

We can't rely on inbound peers to be honest, because they are initiated by others.
It's impossible for us to know, for example, whether all our inbound peers are controlled by the same adversary.

Therefore, in order to try to be connected to the honest network, we focus on having good outbound peers, as we get to choose who those are.
____

The document, which is worth reading in its entirely, continues by assuming the case that we don't have any inbound peers but also considering that any inbound peers we _do_ have can't interfere with the P2P logic proposed.

== Addrman and eclipse attacks

In order to make "at least one connection to that network of peers that share its consensus rules", as the philosophy above targets, a Bitcoin Core node needs to have some node (ip) addresses to connect to which are _not_ controlled by a potential attacker.

When the node has never connected to the bitcoin P2P network before it has no choice but to fetch addresses from a hardcoded DNS seed, the list of which can be found in https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/chainparams.cpp#L121-L129[_src/chainparams.cpp_].
If the node is fed only attacker-controlled addresses by the seed then it has little/no opportunity to join the rest of the honest network.
However, if one or more of the addresses returned by the DNS query are honest then we want the node to be able to (eventually) find and connect to the honest network.

The concepts involved in this process, including how address-based (eclipse) attacks work, how Bitcoin Core manages and tries connections to new (node) addresses, countermeasures deployed to try and prevent naive eclipse attacks, some partially-deployed countermeasures and currently-open research questions can be found in the bitcoin devwiki article https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Addrman-and-eclipse-attacks[Addrman and eclipse attacks].

== Connection overview

Outbound connections from Bitcoin Core are initiated as part of startup from within https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/init.cpp#L1841-L1932[_src/init.cpp_] after the connection manager, `CConnman`, is started via `node.connman->Start()`.

`CConnman::Start()` will first attempt to bind to any specified bind addresses, before adding any addresses supplied as command-line argument, or any found in `peers.dat` to its addrman.

.src/net.cpp#CConnman::Start
[source]
----
    if (fListen && !InitBinds(connOptions.vBinds, connOptions.vWhiteBinds, connOptions.onion_binds)) {
        if (clientInterface) {
            clientInterface->ThreadSafeMessageBox(
                _("Failed to listen on any port. Use -listen=0 if you want this."),
                "", CClientUIInterface::MSG_ERROR);
        }
        return false;
    }

    proxyType i2p_sam;
    if (GetProxy(NET_I2P, i2p_sam)) {
        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(GetDataDir() / "i2p_private_key",
                                                                i2p_sam.proxy, &interruptNet);
    }
----


Next comes a check for any peers inside `anchors.dat`:

.src/net.cpp#CConnman::Start
[source]
----
    for (const auto& strDest : connOptions.vSeedNodes) {
        AddAddrFetch(strDest);
    }

    // ...

    // Load addresses from peers.dat
    int64_t nStart = GetTimeMillis();
    {
        CAddrDB adb;
        if (adb.Read(addrman))
            LogPrintf("Loaded %i addresses from peers.dat  %dms\n", addrman.size(), GetTimeMillis() - nStart);
        else {
            addrman.Clear(); // Addrman can be in an inconsistent state after failure, reset it
            LogPrintf("Recreating peers.dat\n");
            DumpAddresses();
        }
    }

    if (m_use_addrman_outgoing) {
        // Load addresses from anchors.dat
        m_anchors = ReadAnchors(GetDataDir() / ANCHORS_DATABASE_FILENAME);
        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {
            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);
        }
        LogPrintf("%i block-relay-only anchors will be tried for connections.\n", m_anchors.size());
    }
----

This will be empty on first run, but if we are later happy with our connection to the bitcoin network our two outbound block-relay-only peers will be saved in this file to aid in subsequent program runs.

Because the networking segment of the code is multi-threaded, two `CSemaphores` are setup next which control the number of connections being made by the node.

.src/net.cpp#CConnman::Start
[source]
----
    if (semOutbound == nullptr) {
        // initialize semaphore
        semOutbound = std::make_unique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));
    }
    if (semAddnode == nullptr) {
        // initialize semaphore
        semAddnode = std::make_unique<CSemaphore>(nMaxAddnode);
    }
----

After this we get to the primary thread initialisation.

.src/net.cpp#CConnman::Start
[source]
----
    //
    // Start threads
    //

    // Send and receive from sockets, accept connections
    threadSocketHandler = std::thread(&TraceThread<std::function<void()> >, "net", std::function<void()>(std::bind(&CConnman::ThreadSocketHandler, this))); <1>

    if (!gArgs.GetBoolArg("-dnsseed", DEFAULT_DNSSEED))
        LogPrintf("DNS seeding disabled\n");
    else
        threadDNSAddressSeed = std::thread(&TraceThread<std::function<void()> >, "dnsseed", std::function<void()>(std::bind(&CConnman::ThreadDNSAddressSeed, this))); <2>

    // Initiate manual connections
    threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, "addcon", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this))); <3>

    if (connOptions.m_use_addrman_outgoing && !connOptions.m_specified_outgoing.empty()) {
        if (clientInterface) {
            clientInterface->ThreadSafeMessageBox(
                _("Cannot provide specific connections and have addrman find outgoing connections at the same."),
                "", CClientUIInterface::MSG_ERROR);
        }
        return false;
    }
    if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty())
        threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, "opencon", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing))); <4>
----

<1> A thread is spawned which manages the accepting (of new) and disconnecting old connections.
<2> If DNS seeds are not disabled, then a thread is spawned to request addresses from the DNS seeds.
<3> A thread is spawned to initiate manual connections (provided at startup).
<4> A thread to make connections from addresses in `addrman`.

It might appear that DNS seeds are being tried before both manual connections and any addresses found in `peers.dat`, however closer inspection of the 109L function `CConnmann::ThreadDNSAddressSeed` reveals that more than half of those lines are spent trying _not_ to query the DNS seeds, as the rationale in the code comments describes:

.src/net.cpp#CConnman::ThreadDNSAddressSeed
[source]
----
// goal: only query DNS seed if address need is acute
// * If we have a reasonable number of peers in addrman, spend
//   some time trying them first. This improves user privacy by
//   creating fewer identifying DNS requests, reduces trust by
//   giving seeds less influence on the network topology, and
//   reduces traffic to the seeds.
// * When querying DNS seeds query a few at once, this ensures
//   that we don't give DNS seeds the ability to eclipse nodes
//   that query them.
// * If we continue having problems, eventually query all the
//   DNS seeds, and if that fails too, also try the fixed seeds.
//   (done in ThreadOpenConnections)
----

We see in that function if we have > 1000 peers (`DNSSEEDS_DELAY_PEER_THRESHOLD`) we will sleep for 5 minutes (`DNSSEEDS_DELAY_MANY_PEERS`) before querying the DNS seeds, but if we have fewer than 1000 peers then we will only sleep for 11 seconds (`DNSSEEDS_DELAY_FEW_PEERS`):

.src/net.cpp#CConnman::ThreadDNSAddressSeed
[source]
----
const std::chrono::seconds seeds_wait_time = (addrman.size() >= DNSSEEDS_DELAY_PEER_THRESHOLD ? DNSSEEDS_DELAY_MANY_PEERS : DNSSEEDS_DELAY_FEW_PEERS);
----

A risk exists where a malicious DNS seeder eclipses a node by returning an enormous number of IP addresses.
We mitigate this risk by limiting the number of IP addresses addrman learns to 256 per DNS seeder.
Further down in `ThreadDNSAddressSeed()` we see such a magic number:

.src/net.cpp#CConnman::ThreadDNSAddressSeed
[source]
----
unsigned int nMaxIPs = 256; // Limits number of IPs learned from a DNS seed
----
