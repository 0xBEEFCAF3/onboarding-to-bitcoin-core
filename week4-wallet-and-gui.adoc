= Week 4: Wallet and GUI
include::settings.adoc[]

== Wallet

=== Wallet architecture

* https://github.com/chaincodelabs/bitcoin-core-onboarding/tree/main/1.1_regions.asciidoc#wallet_region[Bitcoin core onboarding - wallet/] describes the main functions of a wallet, along with some of the differences between legacy and descriptor wallets. 

==== Separation of wallet and node functionality

Both the `bitcoind` and `bitcoin-qt` programs use the same source code for wallet, networking, consensus etc.
`bitcoin-qt` is not simply a wallet/gui "frontend" for `bitcoind` but a stand-alone binary which happens to share much of the same code.
There has been discussion since at least as early as 2014 about https://github.com/bitcoin/bitcoin/issues/3882[splitting wallet code] out from the rest of the codebase, however this has not been completed yet.

The https://github.com/bitcoin-core/bitcoin-devwiki/wiki//Process-Separation[Process Separation] project is tracking development working towards separating out node, wallet and GUI code even further.
In the mean time developers have preferred to focus on improving the organisation of the (wallet) source code within the project and to focus on making wallet code more asynchronous and independent of node code, to avoid locking the node while wallet code-paths are executing.

==== Wallet interfaces

In order to facilitate code separation, distinct interfaces between the node and the wallet have been created:

* The node holds a https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/interfaces.cpp#L109[`WalletImpl`] interface to call functions on the wallet.
* The wallet holds a https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/node/interfaces.cpp#L429[`ChainImpl`] interface to call functions on the node.
* The node notifies the wallet about new transactions and blocks through the https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/node/interfaces.cpp#L341[`CValidationInterface`].

=== Overview

. Wallets are stored on disk as databases, either using Berkeley Database (BDB) or sqlite format.
. These wallets can be one of two types, "legacy" or https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/doc/descriptors.md["descriptor"].
. Wallets do *not* have to store the private keys associated with the addresses and public keys they are monitoring.
. Wallets can be loaded at startup (by passing `-wallet=` or `-walletdir=` options to `bitcoind`/`bitcoin-qt`) or afterwards via RPC command.
. Wallets are initialised as `CWallet` objects, and a pointer to their interface is stored in the global vector `vpwallets` which is guarded by the main wallet mutex, `cs_wallets`.
. When performing wallet operations `GetWallet` (or `GetWallets`) is often called first with the wallet name as argument, and a `std::shared_ptr` to the desired `CWallet` is returned for the operation to be performed on.
+
.src/wallet/wallet.cpp
[source]
----
std::shared_ptr<CWallet> GetWallet(const std::string& name)
{
    LOCK(cs_wallets);
    for (const std::shared_ptr<CWallet>& wallet : vpwallets) {
        if (wallet->GetName() == name) return wallet;
    }
    return nullptr;
}
----

=== Wallet component initialisation

The wallet component is initialised via the `WalletInitInterface` class as specified in https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/walletinitinterface.h#L11-L23[_src/walletinitinterface.h_].
The member functions are marked as virtual in the `WalletInitInterface` definition, indicating that they are going to be overridden later by a derived class.

.src/walletinitinterface.h
[source]
----
class WalletInitInterface {
public:
    /** Is the wallet component enabled */
    virtual bool HasWalletSupport() const = 0;
    /** Get wallet help string */
    virtual void AddWalletOptions(ArgsManager& argsman) const = 0;
    /** Check wallet parameter interaction */
    virtual bool ParameterInteraction() const = 0;
    /** Add wallets that should be opened to list of chain clients. */
    virtual void Construct(NodeContext& node) const = 0;

    virtual ~WalletInitInterface() {}
}
----

Both _walletinit.cpp_ and _dummywallet.cpp_ include derived classes which override the member functions of `WalletInitInterface`, depending on whether the wallet is being compiled in or not.

The primary https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/Makefile.am#L362-L367[_src/Makefile.am_] describes which of these modules is chosen to override: if `./configure` has been run with the wallet feature enabled (default), then _wallet/init.cpp_ is added to the sources, otherwise (`./configure --disable-wallet`) _dummywallet.cpp_ is added.

.src/Makefile.am
[source, sh]
----
if ENABLE_WALLET
libbitcoin_server_a_SOURCES += wallet/init.cpp
endif
if !ENABLE_WALLET
libbitcoin_server_a_SOURCES += dummywallet.cpp
endif
----

_src/walletinitinterface.h_ declares the global `g_wallet_init_interface`  which will handle the configured `WalletInitInterface`.

The wallet interface is created when the `Construct()` method is called on the `g_wallet_init_interface` object by https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/init.cpp#L1180-L1189[`AppInitInterfaces()`] in _init.cpp_.
`Construct` takes a reference to a `NodeContext` as argument, and then checks that the wallet has not been disabled by a runtime argument before calling `interfaces::MakeWalletClient()` on the node.
This initialises a new `WalletClientImpl` object which is then added to the `node` object, both to the general list of `node.chain_clients` (wallet processes or other clients which want chain information from the node) in addition to being assigned as the unique `node.wallet_client` role, which specifies the particular `node.chain_client` that should be used to load or create wallets.

.src/wallet/init.cpp
[source]
----
void WalletInit::Construct(NodeContext& node) const
{
    ArgsManager& args = *Assert(node.args);
    if (args.GetBoolArg("-disablewallet", DEFAULT_DISABLE_WALLET)) {
        LogPrintf("Wallet disabled!\n");
        return;
    }
    auto wallet_client = interfaces::MakeWalletClient(*node.chain, args);
    node.wallet_client = wallet_client.get();
    node.chain_clients.emplace_back(std::move(wallet_client));
----

The `NodeContext` struct is defined as the following:

.src/node/context.h
[quote]
____
...contains references to chain state and connection state.

...used by init, rpc, and test code to pass object references around without needing to declare the same variables and parameters repeatedly, or to use globals...
The struct isn't intended to have any member functions.
It should just be a collection of references that can be used without pulling in unwanted dependencies or functionality.
____

=== Wallets and program initialisation

Wallets can optionally be loaded as part of main program startup (i.e. from _src/init.cpp_).
Any wallets loaded during the life cycle of the main program are also unloaded as part of program shutdown.

==== Specifying wallets loaded at startup

Wallet(s) to be loaded as part of program startup can be specified by passing `-wallet=` or `-walletdir=` arguments to `bitcoind`/`bitcoin-qt`.
If the wallet has been compiled in but no `-wallet*=` arguments have been passed, then the default wallet directory (_$datadir/wallets_) will be checked as per `GetWalletDir()`:

.src/wallet/walletutil.cpp
[source]
----
fs::path GetWalletDir()
{
    fs::path path;

    if (gArgs.IsArgSet("-walletdir")) {
        path = gArgs.GetArg("-walletdir", "");
        if (!fs::is_directory(path)) {
            // If the path specified doesn't exist, we return the deliberately
            // invalid empty string.
            path = "";
        }
    } else {
        path = GetDataDir();
        // If a wallets directory exists, use that, otherwise default to GetDataDir
        if (fs::is_directory(path / "wallets")) {
            path /= "wallets";
        }
    }

    return path;
}
----

Wallets can also be loaded after program startup via the `loadwallet` RPC.

==== VerifyWallets

Wallet verification refers to verification of the `-wallet` arguments as well as the underlying wallet database(s) on disk.

Wallets loaded via program arguments are first verified as part of `AppInitMain` which first https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/init.cpp#L1301-L1305[verifies wallet database integrity] by calling https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/load.cpp#L19-L88[VerifyWallets] via the `WalletClientImpl` override of `client->verify`.

`VerifyWallets` takes an `interfaces::Chain` object as argument, which is currently used primarily to send init and error messages (about wallet verification) back to the GUI.
`VerifyWallets` starts by checking that the `walletdir` supplied by argument, or default of `""`, is valid.
Next it loops through all wallets it finds in the `walletdir` and adds them to an `std::set` called `wallet_paths`, first deduplicating them by tracking their absolute paths, and then checking that  the `WalletDatabase` for each wallet exists (or is otherwise constructed successfully) and can be verified.

.src/wallet/load.cpp#VerifyWallets
[source]
----
// ...

for (const auto& wallet_file : gArgs.GetArgs("-wallet")) {
    const fs::path path = fsbridge::AbsPathJoin(GetWalletDir(), wallet_file);

    if (!wallet_paths.insert(path).second) {
        chain.initWarning(strprintf(_("Ignoring duplicate -wallet %s."), wallet_file));
        continue;
    }

    DatabaseOptions options;
    DatabaseStatus status;
    options.require_existing = true;
    options.verify = true;
    bilingual_str error_string;
    if (!MakeWalletDatabase(wallet_file, options, status, error_string)) {
        if (status == DatabaseStatus::FAILED_NOT_FOUND) {
            chain.initWarning(Untranslated(strprintf("Skipping -wallet path that doesn't exist. %s", error_string.original)));
        } else {
            chain.initError(error_string);
            return false;
        }
    }
}

// ...
----

If this check passes for all wallets, then `VerifyWallets` is complete and will return `true` back to calling function `AppInitMain`, otherwise `false` will be returned.
If `VerifyWallets` fails and returns `false` (due to a corrupted wallet database, but notably not due to an incorrect wallet path), the main program process `AppInit` will be immediately interrupted and shutdown.

==== LoadWallets

"Startup" wallet(s) are loaded  when `client->load` is called on each `node.chain_client` as part of https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/init.cpp#L1728-L1732[init.cpp].

.src/init.cpp#AppInitMain
[source]
----
for (const auto& client : node.chain_clients) {
    if (!client->load()) {
        return false;
    }
}
----

The call to  `load` on the wallet `chain_client` has again been overridden, this time by ``WalletClientImpl``'s https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/load.cpp#L90-L121[`LoadWallets` method].
This function works similarly to `VerifyWallets`, first creating the `WalletDatabase` (memory) object for each wallet, although this time skipping the verify step, before creating a `CWallet` object from the database and adding it to the global list of wallets, the vector `vpwallets`, by calling https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/load.cpp#L114[`AddWallet`].

.src/wallet/load.cpp#LoadWallets
[source]
----
for (const std::string& name : gArgs.GetArgs("-wallet")) {
    if (!wallet_paths.insert(name).second) {
        continue;
    }
    DatabaseOptions options;
    DatabaseStatus status;
    options.require_existing = true;
    options.verify = false; // No need to verify, assuming verified earlier in VerifyWallets()
    bilingual_str error;
    std::vector<bilingual_str> warnings;
    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(name, options, status, error);
    if (!database && status == DatabaseStatus::FAILED_NOT_FOUND) {
        continue;
    }
    std::shared_ptr<CWallet> pwallet = database ? CWallet::Create(chain, name, std::move(database), options.create_flags, error, warnings) : nullptr;
    if (!warnings.empty()) chain.initWarning(Join(warnings, Untranslated("\n")));
    if (!pwallet) {
        chain.initError(error);
        return false;
    }
    AddWallet(pwallet);
}
----

NOTE: There are a number of steps in `init.cpp` that happen before the wallet is loaded, notably the blockchain is synced first. +
This is a safeguard which means that wallet operations cannot be called on a wallet which has been loaded against stale blockchain data.

NOTE: _init.cpp_ is run on a single thread. +
This means that calls to wallet code block further initialisation of the node.

The `interfaces::Chain` object taken as argument by `LoadWallets()` is used to pass back any error messages, exactly as it was in `VerifyWallets()`.
`AddWallet()` is defined in https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L98-L108[_src/wallet.cpp_].

==== StartWallets

The wallet is finally ready when (all) `chain_clients` have been started in https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/init.cpp#L1939-L1941[_init.cpp_] which calls the overridden `client->start` method from the `WalletClientImpl` class, resulting in https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/load.cpp#L123-L134[src/wallet/load.cpp#StartWallets] being called.

This calls the `GetWallets` function which returns the vector of pointers to the interfaces for loaded `CWallet` objects, `vpwallets`.
As part of startup `PostInitProcess` is called on each wallet which, after grabbing the main wallet lock `cs_wallet`, synchronises the wallet and mempool by adding wallet transactions not yet in a block to our mempool, and updating the wallet with any relevant transactions from the mempool.

.src/wallet/wallet.cpp
[source]
----
void CWallet::postInitProcess()
{
    LOCK(cs_wallet);

    // Add wallet transactions that aren't already in a block to mempool
    // Do this here as mempool requires genesis block to be loaded
    ReacceptWalletTransactions();

    // Update wallet transactions with current mempool transactions.
    chain().requestMempoolTransactions(*this);
}
----

Also, as part of `StartWallets`, `flushwallet` might be scheduled (if configured by argument) scheduling wallet transactions to be re-broadcast every second, although this interval is https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L2104-L2147[delayed upstream with a random timer].

==== FlushWallets

All wallets loaded into the program are "flushed" (to disk) before shutdown.
As part of `init.cpp#Shutdown()` the `flush` method is called on each member of `node.chain_clients` in sequence.
`WalletClientImpl` again overrides this method to call `wallet/load.cpp#FlushWallets()` which makes sure all wallet changes have been successfully flushed to the wallet database.

.src/init.cpp#shutdown
[source]
----
// FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing
if (node.chainman) {
    LOCK(cs_main);
    for (CChainState* chainstate : node.chainman->GetAll()) {
        if (chainstate->CanFlushToDisk()) {
            chainstate->ForceFlushStateToDisk();
        }
    }
}
----

// TODO: Find out why we flush again here?
Finally the `stop` method is called on each member of `node.chain_clients` which is overridden by `StopWallets`, flushing again and this time calling `close` on the database file.

=== Wallet Locks

Grepping the _src/wallet_ directory for locks, conventionally of the form `cs_*`, yields 501 matches.
For comparison the entire remainder of the codebase excluding _src/wallet/*_ yields 925 matches.
Many of these matches are asserts and declarations, however this still illustrates that the wallet code is highly reliant on locks to perform atomic operations.

==== The `cs_wallet` lock

In order to not block the rest of the program during wallet operations, each `CWallet` has its own recursive mutex `cs_wallet`:
Note that there is currently an https://github.com/bitcoin/bitcoin/issues/19303[issue] tracking replacement of RecursiveMutexes with Mutexes, to make locking logic easier to follow in the codebase.

.src/wallet/wallet.h
[source]
----
/*
 * Main wallet lock.
 * This lock protects all the fields added by CWallet.
 */
mutable RecursiveMutex cs_wallet;
----

Most wallet operations whether reading or writing data require the use of the lock so that atomicity can be guaranteed.
Some examples of wallet operations requiring the lock include:

. Creating transactions
. Signing transactions
. Broadcasting/committing transactions
. Abandoning transactions
. Bumping transaction (fees)
. Checking `IsMine`
. Creating new addresses
. Calculating balances
. Creating new wallets
. Importing new {priv|pub}keys/addresses
. Importing/dumping wallets

In addition to these higher level functions, most of ``CWallet``'s private member functions also require a hold on `cs_wallet`.

==== Other wallet locks

. _src/wallet/bdb.cpp_, which is responsible for managing BDB wallet databases on disk, has it's own mutex `cs_db`.
. If external signers have been enabled (via `./configure --enable-external-signer`) then they too have their own mutex `cs_desc_man` which is acquired when descriptors are being setup.
. `BlockUntilSyncedToCurrentChain()` has a unique lock exclude placed on it to prevent the caller from holding `cs_main` during its execution, and therefore prevent a possible deadlock:
+
.src/wallet/wallet.h
[source]
----
/**
 * Blocks until the wallet state is up-to-date to /at least/ the current
 * chain at the time this function is entered
 * Obviously holding cs_main/cs_wallet when going into this call may cause
 * deadlock
 */
void BlockUntilSyncedToCurrentChain() const LOCKS_EXCLUDED(::cs_main) EXCLUSIVE_LOCKS_REQUIRED(!cs_wallet);
----

=== Controlling the wallet

As we can see wallet component startup and shutdown is largely driven from outside the wallet codebase from _src/init.cpp_.

Once the wallet component is started, and any parametrised wallets have been verified and loaded, wallet functionality ceases to be called from _init.cpp_ and instead is controlled using external programs in a number of ways.
The wallet can be controlled using `bitcoin-cli`, the `bitcoin-qt` GUI or the stand-alone `bitcoin-wallet` tool.

Both `bitcoind` and `bitcoin-qt` run a (JSON) RPC server which is ready to service, amongst other things, commands to interact with wallets.
The command line tool `bitcoin-cli` will allow interaction of any RPC server started by either `bitcoin` or `bitcoin-qt`.
If using `bitcoin-qt` there is also an RPC console built into the GUI.
If using the `bitcoin-qt` GUI itself then communication with the wallet is done directly via qt's https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/qt/walletmodel.h#L50-L242[`WalletModel` interface].

Commands which can be used to control the wallet via RPC are listed in https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/rpcwallet.cpp#L4584-L4657[_rpcwallet.cpp_].

==== Wallet via RPC

If we take a look at the https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/rpcwallet.cpp#L2562-L2620[`loadwallet` RPC] we can see similarities to ``WalletClientImpl``'s `LoadWallets()` function.

However this time the function will check the `WalletContext` to check that we have a wallet context (in this case a reference to a chain interface) loaded.
Next it will call https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L237-L248[`wallet.cpp#LoadWallet`] which starts by grabbing `g_wallet_loading_mutex` and adding the wallet to `g_loading_wallet_set`, before calling https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L207-L234[`LoadWalletInternal`] which adds the wallet to `vpwallets` and sets up various event notifications.

.src/wallet/rpcwallet.cpp#loadwallet
[source]
----
WalletContext& context = EnsureWalletContext(request.context);
const std::string name(request.params[0].get_str());

DatabaseOptions options;
DatabaseStatus status;
options.require_existing = true;
bilingual_str error;
std::vector<bilingual_str> warnings;
std::optional<bool> load_on_start = request.params[1].isNull() ? std::nullopt : std::optional<bool>(request.params[1].get_bool());
std::shared_ptr<CWallet> const wallet = LoadWallet(*context.chain, name, load_on_start, options, status, error, warnings);
if (!wallet) {
    // Map bad format to not found, since bad format is returned when the
    // wallet directory exists, but doesn't contain a data file.
    RPCErrorCode code = RPC_WALLET_ERROR;
    switch (status) {
        case DatabaseStatus::FAILED_NOT_FOUND:
        case DatabaseStatus::FAILED_BAD_FORMAT:
            code = RPC_WALLET_NOT_FOUND;
            break;
        case DatabaseStatus::FAILED_ALREADY_LOADED:
            code = RPC_WALLET_ALREADY_LOADED;
            break;
        default: // RPC_WALLET_ERROR is returned for all other cases.
            break;
----

Further operation of the wallet RPCs are detailed in their man pages, but one thing to take note of is that whilst `loadwallet` (and `unloadwallet`) both take a `wallet_name` argument, the other wallet RPCs do not.
Therefore in order to control a `bitcoin{d|-qt}` that has multiple wallets loaded simultaneously via RPC, bitcoin-cli must be called with the -rpcwallet argument, to specify the wallet which the action should be performed against, e.g. `bitcoin-cli --rpcwallet=your_wallet_name getbalance`

=== CWallet

The `CWallet` object is the fundamental wallet representation inside Bitcoin Core.
CWallet stores transactions and balances and has the ability to create new transactions.
CWallet also contains references to the chain interface for the wallet along with storing wallet metadata such as `nWalletVersion`, wallet flags, wallet name and address book.

==== CWallet creation

The CWallet constructor takes a pointer to the chain interface for the wallet, a wallet name and a pointer to the underlying WalletDatabase:

.src/wallet/wallet.h
[source]
----
/** Construct wallet with specified name and database implementation. */
CWallet(interfaces::Chain* chain, const std::string& name, std::unique_ptr<WalletDatabase> database)
    : m_chain(chain),
      m_name(name),
      m_database(std::move(database))
{
}
----

The constructor is not called directly, but instead from the public function `CWallet::Create()`, which is in turn itself called from `CreateWallet`, `LoadWallets` (or `TestLoadWallet`).
In addition to the arguments required by the constructor, `CWallet::Create()` also has a `wallet_flags` argument.
Wallet flags are represented as a single `unit64_t` bit field which encode certain wallet properties:

.src/wallet/walletutil.h
[source]
----
enum WalletFlags : uint64_t {
    WALLET_FLAG_AVOID_REUSE = (1ULL << 0),
    WALLET_FLAG_KEY_ORIGIN_METADATA = (1ULL << 1),
    WALLET_FLAG_DISABLE_PRIVATE_KEYS = (1ULL << 32),
    WALLET_FLAG_BLANK_WALLET = (1ULL << 33),
    WALLET_FLAG_DESCRIPTORS = (1ULL << 34),
    WALLET_FLAG_EXTERNAL_SIGNER = (1ULL << 35),
};
----

See https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/walletutil.h#L35-L66[_src/wallet/walletutil.h_] for additional information on the meanings of the wallet flags.

`CWallet::Create()` will first attempt to create the `CWallet` object and load it, returning if any errors are encountered.
If `CWallet::Create` is creating a new wallet -- on its 'first run' -- the wallet version and wallet flags will be set, before (if private keys are not disabled) either `LegacyScriptPubkeyMan` or ``DescriptorScriptPubkeyMan``'s are setup, depending on whether the `WALLET_FLAG_DESCRIPTORS` flag was set on the wallet.
If the wallet has been created with the `WALLET_FLAG_DISABLE_PRIVATE_KEYS` wallet flag set, then neither type of `ScriptPubkeyMans` will be created.

Following successful creation, various `bitcoind` program arguments are checked and applied to the wallet.
These include options such as "-addresstype", "-changetype", "-mintxfee" and "-maxtxfee" amongst others.
It is at this stage that warnings for unusual or unsafe values of these arguments are generated to be returned to the user.

After the wallet is fully initialised and setup, its <<keypool, `KeyPool`>> will be topped up before the wallet is locked and registered with the <<validation-interface,`validationinterface`>>, which will handle callback notifications generated during the (optional) upcoming chain rescan.
The rescan is smart in detecting the wallet "birthday" using metadata stored in the ScriptPubKeyMan and won't scan blocks produced before this date:

.src/wallet/wallet.cpp
[source]
----
...

chain.initMessage(_("Rescanning...").translated);
walletInstance->WalletLogPrintf("Rescanning last %i blocks (from block %i)...\n", *tip_height - rescan_height, rescan_height);

// No need to read and scan block if block was created before
// our wallet birthday (as adjusted for block time variability)
std::optional<int64_t> time_first_key;
for (auto spk_man : walletInstance->GetAllScriptPubKeyMans()) {
    int64_t time = spk_man->GetTimeFirstKey();
    if (!time_first_key || time < *time_first_key) time_first_key = time;
}
if (time_first_key) {
    chain.findFirstBlockWithTimeAndHeight(*time_first_key - TIMESTAMP_WINDOW, rescan_height, FoundBlock().height(rescan_height));
}

{
    WalletRescanReserver reserver(*walletInstance);
    if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(chain.getBlockHash(rescan_height), rescan_height, {} /* max height */, reserver, true /* update */).status)) {
        error = _("Failed to rescan the wallet during initialization");
        return nullptr;
    }
}

...

----

Finally, the `walletinterface` is setup for the wallet before the `WalletInstance` is returned to the caller.

=== ScriptPubkeyManager

Each wallet contains one or more https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/scriptpubkeyman.h#L169[``ScriptPubkeyManager``s], who are in control of storing the ``scriptPubkey``s managed by that wallet.

A `CWallet` in the general sense therefore becomes "a collection of ``ScriptPubkeyManager``s", which are each managing an address type.
In the current implementation, this means that a default (descriptor) wallet consists of 6 ``ScriptPubkeyManager``s, one for each of combination of {legacy | p2sh | bech32} for {receive | change} addresses.
However note that as shown below in the setup function for Legacy (i.e. non-descriptor) wallets, that in reality they only have one SPK manager, which is then aliased and shared between all output types.

.src/wallet/wallet.cpp
[source]
----
void CWallet::SetupLegacyScriptPubKeyMan()
{
    if (!m_internal_spk_managers.empty() || !m_external_spk_managers.empty() || !m_spk_managers.empty() || IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {
        return;
    }

    auto spk_manager = std::unique_ptr<ScriptPubKeyMan>(new LegacyScriptPubKeyMan(*this));
    for (const auto& type : OUTPUT_TYPES) {
        m_internal_spk_managers[type] = spk_manager.get();
        m_external_spk_managers[type] = spk_manager.get();
    }
    m_spk_managers[spk_manager->GetID()] = std::move(spk_manager);
}
----

Compare this to the equivalent descriptor wallet code fragment which sets up an SPK Man for each output type:

.src/wallet/wallet.cpp#SetupDescriptorScriptPubKeyMans
[source]
----
...

for (bool internal : {false, true}) {
    for (OutputType t : OUTPUT_TYPES) {
        auto spk_manager = std::unique_ptr<DescriptorScriptPubKeyMan>(new DescriptorScriptPubKeyMan(*this, internal));
        if (IsCrypted()) {
            if (IsLocked()) {
                throw std::runtime_error(std::string(__func__) + ": Wallet is locked, cannot setup new descriptors");
            }
            if (!spk_manager->CheckDecryptionKey(vMasterKey) && !spk_manager->Encrypt(vMasterKey, nullptr)) {
                throw std::runtime_error(std::string(__func__) + ": Could not encrypt new descriptors");
            }
        }
        spk_manager->SetupDescriptorGeneration(master_key, t);
        uint256 id = spk_manager->GetID();
        m_spk_managers[id] = std::move(spk_manager);
        AddActiveScriptPubKeyMan(id, t, internal);
    }
}

...
----

Script pubkey managers are stored inside `CWallet` in a map according to output type:

.src/wallet/wallet.h
[source]
----
class CWallet final : public WalletStorage, public interfaces::Chain::Notifications
{
private:

// ...

    std::map<OutputType, ScriptPubKeyMan*> m_external_spk_managers;
    std::map<OutputType, ScriptPubKeyMan*> m_internal_spk_managers;

// ...
}
----

Note that "external" and "internal" (SPKMs) refer to whether the addresses generated are designated for giving out "externally" and receiving new payments to, or for "internal" change addresses.

Prior to c729afd0a3b74a3943e4c359270beaf3e6ff8a7b the equivalent SPK manager functionality (fetching new addresses and signing transactions) was contained within `CWallet` itself, now being split out for better maintainability and upgradability brought by modularisation as per the https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Wallet-Class-Structure-Changes[wallet box class structure changes].
The ultimate effect of this is that the `CWallet` object itself no longer handles keys and addresses.

The change to a `CWallet` made up of (multiple) ``{Descriptor|Legacy}ScriptPubKeyMan``'s is also sometimes referred to as the "Wallet Box" model, where each SPK manager is thought of as a distinct (black?) "box" within the wallet, which can be called upon to perform new address generation and signing functions.

==== Generating keys with Descriptor wallets

===== Legacy wallets and KeyPool

*Legacy wallets* used the "keypool" model which stored a bunch of keys.
The wallet would then simply iterate over each public key and generate a create scriptPubKey (a.k.a. pubkey script) and address for each type of script the wallet supported.
However this approach has a number of shortcomings (from least to most important):

. One key could have multiple addresses
. It was difficult to sign for multisig
. Adding new script functionality required adding new hardcoded script types into the wallet code _for each new type of script_.

Such an approach was not scalable in the long term and so a new format of wallet needed to be introduced.

===== Descriptor Wallets

*Descriptor wallets* instead store output script "descriptors".
These descriptors can be of *any* script type, including arbitrary scripts (which might be "unknown" to the wallet), and mean that wallets can deterministically generate addresses for any type of valid descriptor, as desired by the user.

Descriptors not only contain what is needed to generate an address, they also include all the data needed to "solve" (i.e. spend from) them, i.e. create a valid `scriptSig` (knowledge about which ``redeemScript``s and ``witnessScript``s needed).
The document https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/doc/descriptors.md[Support for Output Descriptors in Bitcoin Core] provides more details and examples of these output descriptors.

=== Validation Interface

=== Key management

==== IsMine

The wallet needs a way to determine whether a transaction it learns about belongs to it.
When a new transaction is learned about (either entering into the mempool or in a new block) the wallet is notified through the https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/node/interfaces.cpp#L341[`CValidationInterface`].
This will call the function https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L1182[`CWallet:SyncTransaction()`] which will in turn call https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L1015[`CWallet::AddToWalletIfInvolvingMe()`].
`AddToWalletIfInvolvingMe` will then call `IsMine` on each output in the transaction, checking the return code to see if a transaction belongs to our wallet.

=== Constructing transactions

=== Multiwallet

Work on the https://github.com/bitcoin/bitcoin/projects/2[multiwallet project] means that Bitcoin Core can now handle dynamic loading and unloading of multiple wallets while running.

== GUI

* Has it's own separate repo at https://github.com/bitcoin-core/gui[bitcoin-core/gui].
* There is useful documentation for developers looking to contribute to the QT side of the codebase found at https://github.com/bitcoin-core/bitcoin-devwiki/wiki//Developer-Notes-for-Qt-Code[Developer Notes for Qt Code].

== Relation to consensus soft forks

Much of the meat of the recently soft-forked changes (e.g. Taproot) reside not inside consensus code, but rather require improvements to the wallet.

== Exercises

[qanda]
question:
answer

== Removed text

* When adding new wallet features which will be included in the GUI, it can be good practice to first implement them as RPC commands because it's easier to create good test coverage for them.
* Advanced transaction signature operations (e.g. signature aggregation, sighash flags) happen in the wallet code.

=== Concepts

* Wallet architecture
* key management
** HD wallets
** Output script descriptors
* Separation of wallet and node functionality
* Key Management
* Transaction Construction
** Taproot
** SegWit
** Bech32
** PSBT
** Coin selection
** CPFP
** RBF
** Transaction batching
** Adaptor signatures
* Multiwallet
* Hardware wallet interface (HWI)
* QT 
